<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Dominion OS Terrain Preview</title>
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
                height: 100%;
                background: #0b0e14;
                color: #e0e6f0;
                font-family: system-ui, sans-serif;
            }
            #top {
                padding: 8px 12px;
                border-bottom: 1px solid #1f2330;
            }
            #stage {
                width: 100%;
                height: calc(100% - 42px);
                display: grid;
                place-items: center;
            }
            canvas {
                width: 90vw;
                height: 70vh;
                border: 1px solid #1f2330;
                background: #111;
            }
            a {
                color: #9ad;
            }
        </style>
    </head>
    <body>
        <div id="top">
            <strong>Terrain Preview</strong>
            <span id="status"></span>
        </div>
        <div id="stage">
            <canvas id="gl"></canvas>
        </div>
        <script>
            (async function () {
                const qs = new URLSearchParams(location.search);
                const job = qs.get("job_id");
                const status = document.getElementById("status");
                if (!job) {
                    status.textContent = " — missing ?job_id";
                    return;
                }
                status.textContent = " — loading…";

                // Fetch assets map then scene.json
                const assetsRes = await fetch(`/v1/gis/jobs/${job}/assets`).catch(() => null);
                if (!assetsRes || !assetsRes.ok) {
                    status.textContent = " — assets not found";
                    return;
                }
                const assets = await assetsRes.json();
                if (!assets.scene || !assets.heightmap) {
                    status.textContent = " — scene/heightmap missing";
                    return;
                }
                const resolveAsset = (p) => {
                    if (!p) return null;
                    if (p.startsWith("http://") || p.startsWith("https://")) return p;
                    if (p.startsWith("/")) return p;
                    return `/v1/gis/jobs/${job}/` + p.replace(/^\\.\\//, "");
                };

                const sceneUrl = resolveAsset(assets.scene);
                const sceneRes = await fetch(sceneUrl).catch(() => null);
                if (!sceneRes || !sceneRes.ok) {
                    status.textContent = " — scene not found";
                    return;
                }
                const scene = await sceneRes.json();
                const hmUrl = resolveAsset(scene.heightmap || assets.heightmap);
                if (!hmUrl) {
                    status.textContent = " — heightmap missing";
                    return;
                }

                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => {
                    renderHeightmap(img);
                    status.textContent = " — ready";
                };
                img.onerror = () => {
                    status.textContent = " — failed to load heightmap";
                };
                img.src = hmUrl;

                function renderHeightmap(image) {
                    const cvs = document.getElementById("gl");
                    const gl = cvs.getContext("webgl2");
                    if (!gl) {
                        status.textContent = " — WebGL2 not supported";
                        return;
                    }
                    const dpr = Math.max(1, window.devicePixelRatio || 1);
                    const displayWidth = Math.floor(cvs.clientWidth * dpr);
                    const displayHeight = Math.floor(cvs.clientHeight * dpr);
                    if (cvs.width !== displayWidth || cvs.height !== displayHeight) {
                        cvs.width = displayWidth;
                        cvs.height = displayHeight;
                    }
                    gl.enable(gl.DEPTH_TEST);

                    // Plane mesh (grid) displaced in vertex shader from heightmap
                    const vs = `#version 300 es\nprecision highp float;\nlayout(location=0) in vec2 aPos;\nlayout(location=1) in vec2 aUV;\nuniform sampler2D uTex;\nuniform float uScale;\nout vec3 vColor;\nvoid main(){\n  float h = texture(uTex, aUV).r;\n  vec3 pos = vec3(aPos, (h-0.5)*uScale);\n  // simple ortho projection
  gl_Position = vec4(pos.xy, 0.0, 1.0);\n  vColor = vec3(h);
}`;
                    const fs = `#version 300 es\nprecision highp float; in vec3 vColor; out vec4 frag; void main(){ frag=vec4(vColor,1.0);} `;

                    function shader(type, src) {
                        const s = gl.createShader(type);
                        gl.shaderSource(s, src);
                        gl.compileShader(s);
                        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                            console.error(gl.getShaderInfoLog(s));
                        }
                        return s;
                    }
                    const prog = gl.createProgram();
                    gl.attachShader(prog, shader(gl.VERTEX_SHADER, vs));
                    gl.attachShader(prog, shader(gl.FRAGMENT_SHADER, fs));
                    gl.linkProgram(prog);
                    gl.useProgram(prog);

                    // Build grid
                    const res = 128;
                    const verts = [];
                    const uvs = [];
                    for (let y = 0; y <= res; y++) {
                        for (let x = 0; x <= res; x++) {
                            const u = x / res,
                                v = y / res;
                            const px = -1 + 2 * u,
                                py = -1 + 2 * v; // NDC-ish plane
                            verts.push(px, py);
                            uvs.push(u, v);
                        }
                    }
                    const idx = [];
                    for (let y = 0; y < res; y++) {
                        for (let x = 0; x < res; x++) {
                            const i = y * (res + 1) + x;
                            idx.push(i, i + 1, i + res + 1, i + 1, i + res + 2, i + res + 1);
                        }
                    }
                    const vao = gl.createVertexArray();
                    gl.bindVertexArray(vao);
                    const vbo = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW);
                    gl.enableVertexAttribArray(0);
                    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
                    const tbo = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, tbo);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvs), gl.STATIC_DRAW);
                    gl.enableVertexAttribArray(1);
                    gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);
                    const ebo = gl.createBuffer();
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(idx), gl.STATIC_DRAW);

                    // Upload height texture (red channel)
                    const tex = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, tex);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    const c = document.createElement("canvas");
                    c.width = image.width;
                    c.height = image.height;
                    const g = c.getContext("2d");
                    g.drawImage(image, 0, 0);
                    const data = g.getImageData(0, 0, image.width, image.height).data;
                    const red = new Uint8Array(image.width * image.height);
                    for (let i = 0, j = 0; i < data.length; i += 4, j++) {
                        red[j] = data[i];
                    }
                    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
                    gl.texImage2D(
                        gl.TEXTURE_2D,
                        0,
                        gl.R8,
                        image.width,
                        image.height,
                        0,
                        gl.RED,
                        gl.UNSIGNED_BYTE,
                        red,
                    );

                    gl.viewport(0, 0, cvs.width, cvs.height);
                    gl.clearColor(0, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    const uTexLoc = gl.getUniformLocation(prog, "uTex");
                    const uScaleLoc = gl.getUniformLocation(prog, "uScale");
                    gl.uniform1i(uTexLoc, 0);
                    gl.uniform1f(uScaleLoc, 0.6); // displacement scale
                    gl.drawElements(gl.TRIANGLES, idx.length, gl.UNSIGNED_INT, 0);
                }
            })();
        </script>
    </body>
</html>
